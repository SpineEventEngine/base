# Spine Protobuf Compiler plugin

Spine uses [Google Protobuf](https://developers.google.com/protocol-buffers/) as a model definition
language. Some of the framework features require compile-time processing of the data model. For that
a plugin into a Protobuf compiler (a.k.a. `protoc`) is implemented.

## Features

### Message interfaces

Spine `protoc` plugin enables the user to mark certain message classes with interfaces.

To mark a certain message type, add the `(is)` option for the type:

```proto
import "spine/options.proto";

message Cat {
    option (is).java_type = "org.example.Pet";
    option (is).generate = true;
    
    // ...
}
``` 
After recompiling the definition with the Spine Protobuf plugin, a `.java` file declaring the 
`org.example.Pet` interface will be generated and the `Cat` java class will implement that 
interface.

The file with the interface declaration is generated alongside the message class files.

In order to use an existing interface, just don't set `(is).generate = true`.

Similarly to `(is)` option, file-level `(every_is)` option declares that all the message types 
declared in the current file implement the given interface.

```proto
import "spine/options.proto";

option (every_is) = "org.example.Pet";

message Cat {
    // ...
}

message Dog {
    // ...
}

message Hamster {
    // ...
}
```

If both `(is)` and `(every_is)` options are found, both are applied.

Also, both `(is)` and `(every_is)` options support shorter syntax with no explicit package 
declaration. In this case, the package of the current file (either `java_package` or Protobuf
`package`) is used.
```proto
package example;

import "spine/options.proto";

option java_package = "org.example.pet";

message Mouse {
    option (is) = {java_type: "SmallPet" generate: true};
    
    // ...
}
```

In the example above, the Java FQN of the generated message interface is 
`org.example.pet.SmallPet`.
If `java_package` option is absent, the Protobuf package is used instead.

#### Built-in interfaces

The plugin has a number of built-in interfaces that are applied to messages which match a certain 
convention:
 - `io.spine.base.EventMessage` is applied to all top-level messages declared in a file which has
   a name ending with `events.proto`;
 - `io.spine.base.CommandMessage` is applied to all top-level messages declared in a file which has
   a name ending with `commands.proto`;
 - `io.spine.base.RejectionMessage` is applied to all top-level messages declared in a file which
   has a name ending with `rejections.proto`;
 - `io.spine.base.UuidValue` is applied to all messages with a single string field called `uuid`.

## Usage

To enable the Spine `protoc` plugin, use the Spine Gradle plugin and 
the [Protobuf Gradle plugin](https://github.com/google/protobuf-gradle-plugin):
```groovy
apply plugin: "io.spine.tools.spine-model-compiler"
apply plugin: "com.google.protobuf"
```

Make sure to use the Protobuf Gradle plugin of version `0.8.3` or later.

The Spine Gradle plugin automatically attaches the Spine `protoc` plugin to the Protobuf compilation
process performed by Protobuf Gradle plugin.

For that, the Spine `protoc` plugin artifact is fetched from a maven repository and copied into 
the directory `.spine` found under the project root, so that the artifact relative path is 
`<projectDir>/.spine/spine-protoc-plugin-X.X.X.jar`, where `X.X.X` is the version of the downloaded 
artifact, which is equal to the version of the Spine Gradle plugin used.

## How it works

#### Assembling

The plugin consists of two artifacts:
 - a shell runner;
 - the executable JAR with the actual `protoc` plugin.
 
Both the plugins are published alongside with the Spine Gradle plugin. To update the `protoc` 
plugin, the user should update the Gradle plugin.

The shell runner artifact is OS-sensitive, thus when building on different systems 
different artifacts (for [Windows](./plugin_runner.bat) or [Unix-like](./plugin_runner.sh)) are 
used. This switch is performed automatically.

The JAR artifact is the same no matter which shell runner is used.

The JAR contains a simple Java program, which reads from stdin and writes into stdout according to 
the [Protobuf compiler contract](https://developers.google.com/protocol-buffers/docs/reference/other#plugins).

#### Configuration

Spine Gradle plugin configures the project with the notation provided by the Protobuf Gradle plugin.
This includes fetching the required artifacts and referencing them to the Protobuf plugin.

The shell runner artifact is fetched by the Protobuf plugin.
The JAR executable is fetched together with all the declared project dependencies and placed in 
the `.spine` directory by convention.

To ensure the artifacts re-fetch, run the Gradle build with `--refresh-dependencies` flag.

The files generated by the plugin are written under `java` subdirectory of the generation target 
directory (which is by default set to `<projectDir>/generated`).

Please also note, that the `.spine` directory is deleted upon the `:clean` Gradle task by default.

#### Compilation

`protoc` invokes the shell runner and passes a serialized message to it via standard I/O. 
The runner starts the JAR executable with the same input and returns its output to `protoc` 
(again via standard I/O).

This level of indirectness is required since operating system does not treat JAR files as 
executables, so a special CLI command is required to start a JAR. 

On the Protobuf compile time, the plugin handles the code generation requests from `protoc`.
The response contains the Java code to be written. For example, for generating message interfaces, 
plugin responds with the code of the message interfaces themselves and the insertion points, which 
make the message types implement the requested interfaces.  
 
If the passed code gen request is not interesting to the Spine plugin, the response is empty.

---

For the details on the `protoc` plugin development, see the official 
[doc](https://developers.google.com/protocol-buffers/docs/reference/other#plugins).
