/*
 * Copyright 2023, TeamDev. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Redistribution and use in source and/or binary forms, with or without
 * modification, must retain the above copyright notice and the following
 * disclaimer.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package io.spine.internal.gradle.publish

import io.spine.internal.gradle.dokka.dokkaJar
import io.spine.internal.gradle.sourceSets
import org.gradle.api.Project
import org.gradle.api.plugins.JavaPluginExtension
import org.gradle.api.tasks.TaskContainer
import org.gradle.api.tasks.TaskProvider
import org.gradle.api.tasks.bundling.Jar
import org.gradle.kotlin.dsl.get
import org.gradle.kotlin.dsl.named
import org.gradle.kotlin.dsl.register
import org.gradle.kotlin.dsl.withType

/**
 * Excludes Google `.proto` sources from all artifacts.
 *
 * Goes through all registered `Jar` tasks and filters out Google's files.
 */
@Suppress("unused")
fun TaskContainer.excludeGoogleProtoFromArtifacts() {
    withType<Jar>().configureEach {
        exclude { it.isGoogleProtoSource() }
    }
}

/**
 * Locates or creates `sourcesJar` task in this [Project].
 *
 * The output of this task is a `jar` archive. The archive contains sources from `main` source set.
 * The task makes sure that sources from the directories below will be included into
 * a resulted archive:
 *
 *  - Kotlin
 *  - Java
 *  - Proto
 *
 * Java and Kotlin sources are default to `main` source set since it is created by `java` plugin.
 * For Proto sources to be included – [special treatment][protoSources] is needed.
 */
internal fun Project.sourcesJar(): TaskProvider<Jar> = tasks.getOrCreate("sourcesJar") {
    dependOnGenerateProto()
    archiveClassifier.set("sources")
    from(sourceSets["main"].allSource) // Puts Java and Kotlin sources.
    from(protoSources()) // Puts Proto sources.
}

/**
 * Locates or creates `protoJar` task in this [Project].
 *
 * The output of this task is a `jar` archive. The archive contains only
 * [Proto sources][protoSources] from `main` source set.
 */
internal fun Project.protoJar(): TaskProvider<Jar> = tasks.getOrCreate("protoJar") {
    dependOnGenerateProto()
    archiveClassifier.set("proto")
    from(protoSources())
}

/**
 * Locates or creates `testJar` task in this [Project].
 *
 * The output of this task is a `jar` archive. The archive contains compilation output
 * of `test` source set.
 */
internal fun Project.testJar(): TaskProvider<Jar> = tasks.getOrCreate("testJar") {
    archiveClassifier.set("test")
    from(sourceSets["test"].output)
}

/**
 * Locates or creates `javadocJar` task in this [Project].
 *
 * The output of this task is a `jar` archive. The archive contains Javadoc,
 * generated upon Java sources from `main` source set. If javadoc for Kotlin is also needed,
 * apply Dokka plugin. It tunes `javadoc` task to generate docs upon Kotlin sources as well.
 */
internal fun Project.javadocJar(): TaskProvider<Jar> = tasks.getOrCreate("javadocJar") {
    archiveClassifier.set("javadoc")
    from(files("$buildDir/docs/javadoc"))
    dependsOn("javadoc")
}

internal fun TaskContainer.getOrCreate(name: String, init: Jar.() -> Unit): TaskProvider<Jar> =
    if (names.contains(name)) {
        named<Jar>(name)
    } else {
        register<Jar>(name) {
            init()
        }
    }

/**
 * Registers [Jar] tasks, output of which is used as Maven artifacts.
 *
 * By default, only a jar with java compilation output is included into publication. This method
 * registers tasks which produce additional artifacts.
 *
 * The list of additional artifacts to be registered:
 *
 *  1. [sourcesJar] – Java, Kotlin and Proto source files.
 *  2. [protoJar] – only Proto source files.
 *  3. [javadocJar] – documentation, generated upon Java files.
 *  4. [testJar] – compilation output of "test" source set.
 *  5. [dokkaJar] - documentation generated by Dokka.
 *
 * Registration of [protoJar], [testJar] and [dokkaJar] is optional. It can be controlled by the
 * method's parameters.
 *
 * @return the list of the registered tasks.
 */
internal fun Project.registerArtifacts(jarFlags: JarFlags): Set<TaskProvider<Jar>> {

    val tasks = mutableSetOf<TaskProvider<Jar>>()

    val java = extensions.findByType(JavaPluginExtension::class.java)
    java?.run {
        withSourcesJar()
        withJavadocJar()
    }

    // We don't want to have an empty "proto.jar" when a project doesn't have any Proto files.
    if (hasProto() && jarFlags.publishProtoJar) {
        tasks.add(protoJar())
    }

    // Here, we don't have the corresponding `hasTests()` check, since this artifact is disabled
    // by default. And turning it on means "We have tests and need them to be published."
    if (jarFlags.publishTestJar) {
        tasks.add(testJar())
    }

    if (jarFlags.publishDokkaJar) {
        tasks.add(dokkaJar())
    }

    return tasks
}
