/*
 * Copyright 2024, TeamDev. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Redistribution and use in source and/or binary forms, with or without
 * modification, must retain the above copyright notice and the following
 * disclaimer.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
syntax = "proto3";

// API Note on Packaging
// ---------------------
// We do not define the package for this file to allow shorter options for user-defined types.
// This allows to write:
//
//     option (internal) = true;
//
// instead of:
//
//      option (spine.base.internal) = true;
//

// Custom Type Prefix Option
// -------------------------
// The custom `type_url_prefix` option allows to define specify custom type URL prefix for messages
// defined in a proto file. This option is declared in this file. Other proto files must import
// `options.proto` to be able to specify custom type URL prefix.
//
// It is recommended that the import statement is provided before the line with `type_url_prefix`
// option to make it obvious that custom option is defined in the imported file.
//
// For example:
//
// syntax = "proto3";
//
// package my.package;
//
// import "spine/options.proto";
//
// option (type_url_prefix) = "type.example.org";
//

option (type_url_prefix) = "type.spine.io";
option java_multiple_files = true;
option java_outer_classname = "OptionsProto";
option java_package = "io.spine.option";

import "google/protobuf/descriptor.proto";

//
// Reserved Range of Option Field Numbers
// --------------------------------------
// Spine Options use the range of option field numbers from the internal range reserved for
// individual organizations. For details of custom Protobuf options and this range please see:
//
//      https://developers.google.com/protocol-buffers/docs/proto#customoptions
//
// The whole range reserved for individual organizations is 50000-99999.
// The range used by Spine Options is 73812-75000.
// In order to prevent number collision with custom options used by a project based on Spine,
// numbers for custom options defined in this project should be in the range 50000-73811 or
// 75001-99999.
//

extend google.protobuf.FieldOptions {

    // Field Validation Constraints
    //-----------------------------
    // For constraints defined via message-based types, please see documentation of corresponding
    // message types.
    //

    // The option to mark a field as required.
    //
    // When this option is set:
    //
    // 1. For message or enum fields, the field must be set to a non-default instance.
    // 2. For `string` and `bytes` fields, the value must be set to a non-empty string or an array.
    // 3. For repeated fields and maps, at least one element must be present.
    //
    // Other field types are not supported by the option.
    //
    // Unlike the `required` keyword in Protobuf 2, this option does not affect message
    // serialization or deserialization. Even if a message content violates the requirement
    // set by the option, it would still be a valid message for the Protobuf library.
    //
    // Example: Using `(required)` field validation constraint.
    //
    //     message MyOuterMessage {
    //         MyMessage field = 1 [(required) = true];
    //     }
    //
    bool required = 73812;

    // See `IfMissingOption`
    IfMissingOption if_missing = 73813;

    // Reserved 73814 and 73815 for deleted options `decimal_max` and `decimal_min`.

    // A higher boundary to the range of values of a number.
    MaxOption max = 73816;

    // A lower boundary to the range of values of a number.
    MinOption min = 73817;

    // 73818 reserved for the (digits) option.

    // 73819 reserved for the (when) option.

    // See `PatternOption`.
    PatternOption pattern = 73820;

    // Enables in-depth validation for fields that refer to a message.
    //
    // This option applies only to fields that reference a message:
    //
    //   1. Singular message fields.
    //   2. Repeated fields of message types.
    //   3. Map fields with message types as values.
    //
    // When set to `true`, the field is valid only if its value satisfies the validation
    // constraints defined in the corresponding message type:
    //
    //   1. For singular message fields: the message must meet its constraints.
    //
    //      Note: default instances are considered valid even if the message has required fields.
    //      In such cases, it is unclear whether the field is set with an invalid instance or
    //      simply unset.
    //
    //      Example:
    //
    //      ```
    //      // Note that the default instance of `Address` is not valid because the `value` field
    //      // is mandatory.
    //      message Address {
    //          string value = 1 [(required) = true];
    //      }
    //
    //      // However, the default instance of `Address` in `Student.address` is valid, despite
    //      // having `(validate)` constraint that forces the message to meet its constraints.
    //      // Since the `address` field is optional for `Student`, `(validate)` would allow
    //      // default instances for this field treating them as "no value set".
    //      message Student {
    //          Address address = 1 [(validate) = true]; // implicit `(required) = false`.
    //      }
    //
    //      // Make the validated field required to avoid this behavior. In this case, `(validate)`
    //      // continues to bypass default instances, but the `(required)` option will report them.
    //      message Student {
    //          Address address = 1 [(validate) = true, (required) = true];
    //      }
    //      ```
    //
    //   2. For repeated fields: every element in the repeated field must meet the constraints
    //      of its message type.
    //
    //      Example:
    //
    //      ```
    //      // Note that the default instance of `PhoneNumber` is not valid because the `value`
    //      // field is mandatory.
    //      message PhoneNumber {
    //          string value = 1 [(required) = true, (pattern).regex = "^\+?[0-9\s\-()]{1,30}$"];
    //      }
    //
    //      // In contrast to singular fields, the default instances in `repeated` will also be
    //      // reported by the `(validate)` constraint, with those that do not match the pattern.
    //      message Student {
    //          repeated PhoneNumber number = 1 [(validate) = true];
    //      }
    //      ```
    //
    //   3. For map fields: each value in the map must meet the constraints of message type.
    //      Note: Protobuf does not allow messages to be used as map keys.
    //
    //      Example:
    //
    //      ```
    //      // Note that the default instance of `PhoneNumber` is not valid because the `value`
    //      // field is mandatory.
    //      message PhoneNumber {
    //          string value = 1 [(required) = true, (pattern).regex = "^\+?[0-9\s\-()]{1,30}$"];
    //      }
    //
    //      // In contrast to singular fields, the default instances in `map` values will also be
    //      // reported by the `(validate)` constraint, with those that do not match the pattern.
    //      message Contacts {
    //          map<string, PhoneNumber> map = 1 [(validate) = true];
    //      }
    //      ```
    //
    // If the field contains `google.protobuf.Any`, the option will first attempt to unpack
    // the enclosed message, and only then validate it. However, unpacking is not always possible:
    //
    //   1. The default instance of `Any` is always valid because there is nothing to unpack
    //      and validate.
    //   2. Instances with type URLs that are unknown to the application are also valid.
    //
    //      Unpacking requires a corresponding Java class to deserialize the message, but if
    //      the application does not recognize the type URL, it has no way to determine which
    //      class to use.
    //
    //      Such may happen when the packed message comes from a newer app version, an external
    //      system, or is simply not included in the application’s dependencies.
    //
    bool validate = 73821;

    // See `IfInvalidOption`.
    IfInvalidOption if_invalid = 73822 [deprecated = true];

    // See `GoesOption`.
    GoesOption goes = 73823;

    // Indicates that a field can only be set once.
    //
    // This option allows the target field to accept assignments only if one of the following
    // conditions is met:
    //
    // 1. The current field value is the default for its type.
    //    Refer to the official docs on default values: https://protobuf.dev/programming-guides/proto3/#default.
    // 2. The current field value equals to the proposed new value.
    //
    // The option can be applied to the following singular field types:
    //
    // - any message or enum type;
    // - any numeric type;
    // - `bool`, `string` and `bytes`.
    //
    // Repeated fields, maps, and fields with explicit `optional` cardinality are not supported.
    // Such declarations will lead to build-time errors. For more information on field cardinality,
    // refer to the official docs: https://protobuf.dev/programming-guides/proto3/#field-labels.
    //
    // Assigning a value to a message field can be done in various ways in the generated code.
    // It depends on the target language and specific implementation of `protoc`. This option
    // doesn't enforce field immutability at the binary representation level. Also, it does not
    // prevent the use of Protobuf utilities that can construct new messages without using field
    // setters or properties. The primary purpose of this option is to support standard use cases,
    // such as assigning values through setters or retrieving them during data merging.
    //
    // For example, let's take a look on how it works for the generated Java code. The following
    // use cases are supported and validated by the option:
    //
    // 1. Assigning a field value using the field setter.
    // 2. Assigning a field value using the field descriptor.
    // 3. Merging data from another instance of the message class.
    // 4. Merging data from a message's binary representation.
    // 5. Merging specific fields (available for Message fields).
    //
    // Unsupported Java use cases include:
    //
    // 1. Constructing a message using the `DynamicMessage` class.
    // 2. Merging data from messages provided by third-party Protobuf implementations.
    // 3. Clearing a specific field or an entire message.
    //
    // For unsupported scenarios, the option performs no validation. It does not throw errors
    // or print warnings.
    //
    // A typical use case involves a field, such as an ID, which remains constant throughout
    // the lifecycle of an entity.
    //
    // Example: using `(set_once)` field validation constraint.
    //
    //     message User {
    //         UserId id = 1 [(set_once) = true];
    //     }
    //
    // Once set, the `id` field cannot be changed.
    //
    // Use `(if_set_again).error_msg` option to specify a custom error message that will be used for
    // composing the error upon attempting to re-assign the field value. Refer to the documentation
    // for the corresponding option for an example of its usage.
    //
    bool set_once = 73824;

    // The option to enforce uniqueness for collection fields.
    //
    // When the option is set to `true`, the behavior is as follows:
    //
    // 1. For `repeated` fields: all elements must be unique.
    // 2. For `map` fields: while the map keys are inherently unique, all associated values
    //    must also be unique.
    //
    // Other field types are not supported.
    //
    // Uniqueness is determined by comparing the elements themselves, using their full equality.
    // For example, in Java, it is defined by the `equals()` method. No special cases are applied,
    // such as comparing only specific fields like IDs.
    //
    // Example: using `(distinct)` constraint for a `repeated` field.
    //
    //    message Blizzard {
    //
    //        // All snowflakes must be unique in this blizzard.
    //        //
    //        // Attempting to add a snowflake that is equal to an existing one would result
    //        // in a constraint violation error.
    //        //
    //        repeated Snowflake snowflakes = 1 [(distinct) = true];
    //    }
    //
    // Example: using `(distinct)` constraint for a `map` field.
    //
    //    message UniqueEmails {
    //
    //        // The associated email values must be unique.
    //        //
    //        // Attempting to add a key/value pair where the `Email` value duplicates
    //        // an existing one would result in a constraint violation error.
    //        //
    //        map<string, Email> emails = 1 [(distinct) = true];
    //    }
    //
    bool distinct = 73825;

    // Reserved 73826 for deleted `range` option, which had `string` type.

    // Defines the error message used if a `set_once` field is set again.
    //
    // Applies only to the fields marked as `set_once`.
    //
    IfSetAgainOption if_set_again = 73827;

    // Defines the error message used if a `distinct` field has duplicates.
    //
    // Applies only to the repeated fields marked as `distinct`.
    //
    IfHasDuplicatesOption if_has_duplicates = 73828;

    // The option to indicate that a numeric field is required to have a value which belongs
    // to the specified bounded range.
    //
    // For unbounded ranges, please use `(min)` and `(max) options.
    //
    RangeOption range = 73829;

    // Reserved 73830 to 73849 for future validation options.

    // API Annotations
    //-----------------

    // Indicates a field which is internal to Spine, not part of the public API, and should not be
    // used by users of the framework.
    //
    // If you plan to implement an extension of the framework, which is going to be
    // wired into the framework, you may use the internal parts. Please consult with the Spine
    // team, as the internal APIs do not have the same stability API guarantee as public ones.
    //
    bool internal = 73850;

    // Reserved 73851 for the deleted SPI option.

    // Indicates a field that can change at any time, and has no guarantee of API stability and
    // backward-compatibility.
    //
    // Usage guidelines:
    // 1. This annotation is used only on public API. Internal interfaces should not use it.
    // 2. This annotation can only be added to new API. Adding it to an existing API is considered
    //    API-breaking.
    // 3. Removing this annotation from an API gives it stable status.
    //
    bool experimental = 73852;

    // Signifies that a public API is subject to incompatible changes, or even removal, in a future
    // release.
    //
    // An API bearing this annotation is exempt from any compatibility guarantees made by its
    // containing library. Note that the presence of this annotation implies nothing about the
    // quality of the API in question, only the fact that it is not "API-frozen."
    // It is generally safe for applications to depend on beta APIs, at the cost of
    // some extra work during upgrades.
    //
    bool beta = 73853;

    // Marks an entity state field as column.
    //
    // The column fields are stored separately from the entity record and can be specified as
    // filtering criteria during entity querying.
    //
    // The column field should be declared as follows:
    //
    // message UserProfile {
    //    ...
    //    int32 year_of_registration = 8 [(column) = true];
    // }
    //
    // The `year_of_registration` field value can then be used as query parameter when reading
    // entities of `UserProfile` type from the server side.
    //
    // The value of a column field can be updated in two ways:
    //
    // 1. In the receptors of the entity, just like any other part of entity state.
    // 2. Using the language-specific tools like `EntityWithColumns` interface in Java.
    //
    // All column fields are considered optional by the framework.
    //
    // Currently, only entities of projection and process manager type are
    // eligible for having columns (see `EntityOption`).
    // For all other message types the column declarations are ignored.
    //
    // The `repeated` and `map` fields cannot be columns.
    //
    bool column = 73854;

    // Reserved 73855 to 73890 for future options.

    // Reserved 73900 for removed `by` option.
}

extend google.protobuf.OneofOptions {

    // Deprecated: use the `(choice)` option instead.
    bool is_required = 73891 [deprecated = true];

    // Controls whether a `oneof` group must always have one of its fields set.
    ChoiceOption choice = 73892;

    // Reserved 73893 to 73899 for future options.
}

extend google.protobuf.MessageOptions {

    // Validation Constraints
    //------------------------

    // The default validation error message.
    //
    // Please note, this option is intended for INTERNAL USE only. It applies to message types
    // that extend `FieldOptions` and is not intended for external usage.
    //
    // If a validation option detects a constraint violation and no custom error message is defined
    // for that specific option, it will fall back to the message specified by `(default_message)`.
    //
    // For example, here is how to declare the default message for `(goes)` option:
    //
    // ```
    // message GoesOption {
    //   // The default error message.
    //   option (default_message) = "The field `${goes.companion}` must also be set when `${field.path}` is set.";
    // }
    // ```
    //
    // Note: The placeholders available within `(default_message)` depend solely on the particular
    // validation option that uses it. Each option may define its own set of placeholders, or none.
    //
    string default_message = 73901 [(internal) = true];

    // Deprecated: use the `(require)` option instead.
    string required_field = 73902 [deprecated = true];

    // See `EntityOption`.
    EntityOption entity = 73903;

    // An external validation constraint for a field.
    //
    // WARNING: This option is deprecated and is scheduled for removal in Spine v2.0.0.
    //
    // Allows to re-define validation constraints for a message when its usage as a field of
    // another type requires alternative constraints. This includes definition of constraints for
    // a message which does not have them defined within the type.
    //
    // A target field of an external constraint should be specified using a fully-qualified
    // field name (e.g. `mypackage.MessageName.field_name`).
    //
    // Example: defining external validation constraint.
    //
    //     package io.spine.example;
    //
    //     // Defines a change in a string value.
    //     //
    //     // Both of the fields of this message are not `required` to be able to describe
    //     // a change from empty value to non-empty value, or from a non-empty value to
    //     // an empty string.
    //     //
    //     message StringChange {
    //
    //          // The value of the field that's changing.
    //          string previous_value = 1;
    //
    //          // The new value of the field.
    //          string new_value = 2;
    //     }
    //
    //     // A command to change a name of a task.
    //     //
    //     // The task has a non-empty name. A new name cannot be empty.
    //     //
    //     message RenameTask {
    //
    //          // The ID of the task to rename.
    //          string task_id = 1;
    //
    //          // Instruction for changing the name.
    //          //
    //          // The value of `change.previous_value` is the current name of the task.
    //          // It cannot be empty.
    //          //
    //          // The value of `change.new_value` is the new name of the task.
    //          // It cannot be empty either.
    //          //
    //          StringChange change = 1 [(validate) = true];
    //     }
    //
    //     // External validation constraint for both fields of the `StringChange` message
    //     // in the scope of the `RenameTask` command.
    //     //
    //     message RequireTaskNames {
    //          option (constraint_for) = "spine.example.RenameTask.change";
    //
    //          string previous_value = 1 [(required) = true];
    //          string new_value = 2 [(required) = true];
    //     }
    //
    // NOTE: A target field for an external validation constraint must be have the option `(validate)`
    //       set to `true`. See the definition of the `RenameTask.change` field in the example
    //       above. If there is no such option defined, or it is set to `false`, the external
    //       constraint will not be applied.
    //
    // External validation constraints can be applied to fields of several types.
    // To do so, separate fully-qualified references to these fields with comma.
    //
    // Example: external validation constraints for multiple fields.
    //
    //     // External validation constraint for requiring a new value in renaming commands.
    //     message RequireNewName {
    //         option (constraint_for) = "spine.example.RenameTask.change,"
    //                                  "spine.example.RenameProject.change,";
    //                                  "spine.example.UpdateComment.text_change;
    //
    //         string new_value = 1 [(required) = true];
    //     }
    //
    // NOTE: An external validation constraint for a field must be defined only once.
    //       Spine Model Compiler does not check such an "overwriting".
    //       See the issue: https://github.com/SpineEventEngine/base/issues/318.
    //
    string constraint_for = 73904 [deprecated = true];

    // Reserved 73905 to 73910 for future validation options.

    // API Annotations
    //-----------------

    // Indicates a type usage of which is restricted in one of the following ways.
    //
    // 1. This type is internal to the Spine Event Engine framework. It is not a part of
    // the public API, and must not be used by framework users.
    //
    // 2. The type is internal to a bounded context, artifact of which exposes the type to
    // the outside world (presumably for historical reasons).
    //
    // The type with such an option can be used only inside the bounded context which declares it.
    //
    // The type must not be used neither for inbound (i.e. being sent to the bounded context
    // which declares this type) nor for outbound communication (i.e. being sent by this
    // bounded context outside).
    //
    // An attempt to violate these usage restrictions will result in a runtime error.
    //
    bool internal_type = 73911;

    // Indicates a file which contains elements of Service Provider Interface (SPI).
    bool SPI_type = 73912;

    // Indicates a public API that can change at any time, and has no guarantee of
    // API stability and backward-compatibility.
    bool experimental_type = 73913;

    // Signifies that a public API is subject to incompatible changes, or even removal,
    // in a future release.
    bool beta_type = 73914;

    // Specifies a characteristic inherent in the the given message type.
    //
    // Example: using `(is)` message option.
    //
    //     message CreateProject {
    //         option (is).java_type = "ProjectCommand";
    //
    //         // Remainder omitted.
    //     }
    //
    // In the example above, `CreateProject` message is a `ProjectCommand`.
    //
    // To specify a characteristic for every message in a `.proto` file,
    // please use `(every_is)` file option.
    //
    // If both `(is)` and `(every_is)` options are applicable for a type, both are applied.
    //
    // When targeting Java, specify the name of a Java interface to be implemented by this
    // message via `(is).java_type`.
    //
    IsOption is = 73915;

    // Reserved 73916 to 73921 for future API annotation options.

    // Reserved 73922 for removed `enrichment_for` option.

    // Specifies the natural ordering strategy for this type.
    //
    // Code generators should generate language-specific comparisons based on the field paths.
    //
    // Runtime comparators may use the reflection API to compare field values.
    //
    CompareByOption compare_by = 73923;

    // The constraint to require at least one of the fields or combinations of fields.
    RequireOption require = 73924;

    // Reserved 73925 to 73938 for future options.

    // Reserved 73939 and 73940 for the deleted options `events` and `rejections`.
}

extend google.protobuf.FileOptions {

    // Specifies a type URL prefix for all types within a file.
    //
    // This type URL will be used when packing messages into `Any`.
    // See `any.proto` for more details.
    //
    string type_url_prefix = 73941;

    // Indicates a file which contains types usage of which is restricted.
    //
    // For more information on such restrictions please see the documentation of
    // the type option called `internal_type`.
    //
    // If a file contains a declaration of a `service`, this option will NOT be applied to it.
    // A service is not a data type, and therefore, this option does not apply to it.
    // Internal services are not supported.
    //
    bool internal_all = 73942;

    // Indicates a file which contains elements of Service Provider Interface (SPI).
    //
    // This option applies to messages, enums, and services.
    //
    bool SPI_all = 73943;

    // Indicates a file declaring public data type API which that can change at any time,
    // has no guarantee of API stability and backward-compatibility.
    //
    // If a file contains a declaration of a `service`, this option will NOT be applied to it.
    // A service is not a data type, and therefore, this option does not apply to it.
    // Experimental services are not supported.
    //
    bool experimental_all = 73944;

    // Signifies that a public data type API is subject to incompatible changes, or even removal,
    // in a future release.
    //
    // If a file contains a declaration of a `service`, this option will NOT be applied to it.
    // A service is not a data type, and therefore, this option does not apply to it.
    // Beta services are not supported.
    //
    bool beta_all = 73945;

    // Specifies a characteristic common for all the message types in the given file.
    //
    // Example: marking all the messages using the `(every_is)` file option.
    // ```
    //     option (every_is).java_type = "ProjectCommand";
    //
    //     message CreateProject {
    //         // ...
    //
    //         message WithAssignee {
    //         // ...
    //         }
    //     }
    //
    //     message DeleteProject { /*...*/ }
    // ```
    //
    // In the example above, `CreateProject`, `CreateProject.WithAssignee`, and `DeleteProject`
    // messages are `ProjectCommand`-s.
    //
    // To specify a characteristic for a single message, please use `(is)` message option.
    // If both `(is)` and `(every_is)` options are applicable for a type, both are applied.
    //
    // When targeting Java, specify the name of a Java interface to be implemented by these
    // message types via `(every_is).java_type`.
    //
    EveryIsOption every_is = 73946;

    // Reserved 73947 to 73970 for future use.
}

extend google.protobuf.ServiceOptions {

    // Indicates that the service is a part of Service Provider Interface (SPI).
    bool SPI_service = 73971;

    // Reserved 73971 to 73980.
}

// Reserved 73981 to 74000 for other future Spine Options numbers.

//
// Validation Option Types
//---------------------------

// Defines the error message used if a `required` field is not set.
//
// Applies only to the fields marked as `required`.
//
message IfMissingOption {

    // The default error message.
    option (default_message) = "The field `${parent.type}.${field.path}`"
        " of the type `${field.type}` must have a non-default value.";

    // A user-defined validation error format message.
    //
    // Use `error_msg` instead.
    //
    string msg_format = 1 [deprecated = true];

    // A user-defined error message.
    //
    // The specified message may include the following placeholders:
    //
    // 1. `${field.path}` – the field path.
    // 2. `${field.type}` – the fully qualified name of the field type.
    // 3. `${parent.type}` – the fully qualified name of the validated message.
    //
    // The placeholders will be replaced at runtime when the error is constructed.
    //
    // Example: using the `(if_missing)` option.
    //
    //    message Student {
    //        Name name = 1 [(required) = true,
    //                       (if_missing).error_msg = "The `${field.path}` field is mandatory for `${parent.type}`."];
    //    }
    //
    string error_msg = 2;
}

// Indicates that the numeric field must be greater than or equal to the specified value.
//
// The option supports all singular and repeated numeric fields.
//
message MinOption {

    // The default error message.
    option (default_message) = "The field `${parent.type}.${field.path}`"
        " must be ${min.operator} ${min.value}. The passed value: `${field.value}`.";

    // The string representation of the minimum field value.
    //
    // ## Integer and floating-point values
    //
    // A minimum value for an integer field must use an integer number. Specifying a decimal
    // number is not allowed, even if it has no fractional part (e.g., `5.0` is invalid).
    //
    // A minimum value for a floating-point field must use a decimal separator (`.`), even if
    // the value has no fractional part. An exponent part represented by `E` or `e`, followed
    // by an optional sign and digits is allowed (e.g., `1.2E3`, `0.5e-2`).
    //
    // Example: defining minimum values for integer and floating-point fields.
    //
    // message Measurements {
    //     int32 temperature = 1 [(min).value = "0"];
    //     uint32 mass = 2 [(min).value = "5"];
    //     float degree = 3 [(min).value = "0.0"];
    //     double angle = 4 [(min).value = "30.0"];
    //     float pressure = 5 [(min).value = "950.0E-2"];
    //  }
    //
    // ## Field Type Limitations
    //
    // A minimum value must not fall below the limits of the field type.
    //
    // Example: invalid values that fall below the field type limits.
    //
    // message OverflowMeasurements {
    //     float pressure = 1 [(min).value = "-5.5E38"]; // Falls below the `float` minimum.
    //     uint32 mass = 2 [(min).value = "-5"]; // Falls below the `uint32` minimum.
    // }
    //
    // ## Field references
    //
    // Instead of numeric literals, you can reference another numeric field.
    // At runtime, the field’s value will be used as the bound. Nested fields are supported.
    //
    // Example: defining minimum values using field references.
    //
    // message Measurements {
    //
    //     int32 min_length = 1;
    //     int32 length = 2 [(min).value = "min_length"];
    //
    //     Limits limits = 3;
    //     int32 temperature = 4 [(min).value = "limits.min_temperature"];
    //     float pressure = 5 [(min).value = "limits.min_pressure"];
    // }
    //
    // message Limits {
    //     int32 min_temperature = 1;
    //     float min_pressure = 2;
    // }
    //
    // Note: Field type compatibility is not required in this case; the value is
    // automatically converted. However, only numeric fields can be referenced.
    // Repeated and map fields are not supported.
    //
    string value = 1;

    // Specifies if the field should be strictly greater than the specified minimum.
    //
    // The default value is false, i.e. the bound is inclusive.
    //
    bool exclusive = 2;

    // A user-defined validation error format message.
    string msg_format = 3 [deprecated = true];

    // A user-defined error message.
    //
    // The specified message may include the following placeholders:
    //
    // 1. `${field.value}` - the field value.
    // 2. `${field.path}` – the field path.
    // 3. `${field.type}` – the fully qualified name of the field type.
    // 4. `${parent.type}` – the fully qualified name of the validated message.
    // 5. `${min.value}` – the specified minimum `value`. For referenced fields, the actual
    //    field value is also printed in round brackets along with the reference itself.
    // 6. `${min.operator}` – if `exclusive` is set to `true`, this placeholder equals to ">".
    //    Otherwise, ">=".
    //
    // The placeholders will be replaced at runtime when the error is constructed.
    //
    string error_msg = 4;
}

// Indicates that the numeric field must be less than or equal to the specified value.
//
// The option supports all singular and repeated numeric fields.
//
message MaxOption {

    // The default error message.
    option (default_message) = "The field `${parent.type}.${field.path}`"
        " must be ${max.operator} ${max.value}. The passed value: `${field.value}`.";

    // The string representation of the maximum field value.
    //
    // ## Integer and floating-point values
    //
    // A maximum value for an integer field must use an integer number. Specifying a decimal
    // number is not allowed, even if it has no fractional part (e.g., `5.0` is invalid).
    //
    // A maximum value for a floating-point field must use a decimal separator (`.`), even if
    // the value has no fractional part. An exponent part represented by `E` or `e`, followed
    // by an optional sign and digits is allowed (e.g., `1.2E3`, `0.5e-2`).
    //
    // Example: defining maximum values for integer and floating-point fields.
    //
    // message Measurements {
    //     int32 temperature = 1 [(max).value = "270"];
    //     uint32 mass = 2 [(max).value = "1200"];
    //     float degree = 3 [(max).value = "360.0"];
    //     double angle = 4 [(max).value = "90.0"];
    //     float pressure = 5 [(max).value = "1050.0E-2"];
    //  }
    //
    // ## Field Type Limitations
    //
    // A maximum value must not exceed the limits of the field type.
    //
    // Example: invalid values that exceed the field type limits.
    //
    // message OverflowMeasurements {
    //     float pressure = 1 [(min).value = "5.5E38"]; // Exceeds the `float` maximum.
    //     int32 mass = 2 [(min).value = "2147483648"]; // Exceeds the `int32` maximum.
    // }
    //
    // ## Field references
    //
    // Instead of numeric literals, you can reference another numeric field.
    // At runtime, the field’s value will be used as the bound. Nested fields are supported.
    //
    // Example: defining maximum values using field references.
    //
    // message Measurements {
    //
    //     int32 max_length = 1;
    //     int32 length = 2 [(max).value = "max_length"];
    //
    //     Limits limits = 3;
    //     int32 temperature = 4 [(max).value = "limits.max_temperature"];
    //     float pressure = 5 [(max).value = "limits.max_pressure"];
    // }
    //
    // message Limits {
    //     int32 max_temperature = 1;
    //     float max_pressure = 2;
    // }
    //
    // Note: Field type compatibility is not required in this case; the value is
    // automatically converted. However, only numeric fields can be referenced.
    // Repeated and map fields are not supported.
    //
    string value = 1;

    // Specifies if the field should be strictly less than the specified maximum
    //
    // The default value is false, i.e. the bound is inclusive.
    //
    bool exclusive = 2;

    // A user-defined validation error format message.
    string msg_format = 3 [deprecated = true];

    // A user-defined error message.
    //
    // The specified message may include the following placeholders:
    //
    // 1. `${field.path}` – the field path.
    // 2. `${field.value}` - the field value.
    // 3. `${field.type}` – the fully qualified name of the field type.
    // 4. `${parent.type}` – the fully qualified name of the validated message.
    // 5. `${max.value}` – the specified maximum `value`. For referenced fields, the actual
    //    field value is also printed in round brackets along with the reference itself.
    // 6. `${max.operator}` – if `exclusive` is set to `true`, this placeholder equals to "<".
    //    Otherwise, "<=".
    //
    // The placeholders will be replaced at runtime when the error is constructed.
    //
    string error_msg = 4;
}

// A string field value must match the given regular expression.
//
// This option is applicable only to string fields,
// including those that are repeated.
//
// Example: using the `(pattern)` option.
//
//     message CreateAccount {
//         string id = 1 [(pattern).regex = "^[A-Za-z0-9+]+$",
//                        (pattern).error_msg = "ID must be alphanumerical in `${parent.type}`. Provided: `${field.value}`."];
//     }
//
message PatternOption {

    // The default error message.
    option (default_message) = "The `${parent.type}.${field.path}` field"
        " must match the regular expression `${regex.pattern}` (modifiers: `${regex.modifiers}`)."
        " The passed value: `${field.value}`.";

    // The regular expression that the field value must match.
    //
    // Please use the Java regex dialect for the syntax baseline:
    // https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/regex/Pattern.html
    //
    // Note: in Java, regex patterns are not wrapped in explicit delimiters like in Perl or PHP.
    // Instead, the pattern is provided as a string literal. Therefore, `/` symbol does not need
    // to be escaped.
    //
    // The provided string literal is passed directly to the regex engine. So, it must be exactly
    // what you would supply to the `java.util.regex.Pattern.compile()` method.
    //
    string regex = 1;

    reserved 2;
    reserved "flag";

    // Modifiers for this pattern.
    Modifier modifier = 4;

    // A user-defined validation error format message.
    string msg_format = 3 [deprecated = true];

    // A user-defined validation error format message.
    //
    // The specified message may include the following placeholders:
    //
    // 1. `${field.path}` – the field path.
    // 2. `${field.value}` - the field value.
    // 3. `${field.type}` – the fully qualified name of the field type.
    // 4. `${parent.type}` – the fully qualified name of the validated message.
    // 5. `${regex.pattern}` – the specified regex pattern.
    // 6. `${regex.modifiers}` – the specified modifiers, if any. For example, `[dot_all, unicode]`.
    //
    // The placeholders will be replaced at runtime when the error is constructed.
    //
    string error_msg = 5;

    // Regular expression modifiers.
    //
    // These modifiers are specifically selected to be supported in many implementation platforms.
    //
    message Modifier {

        // Enables the dot (`.`) symbol to match all the characters.
        //
        // By default, the dot does not match line break characters.
        //
        // May also be known in some platforms as "single line" mode and be encoded with
        // the `s` flag.
        //
        bool dot_all = 1;

        // Allows to ignore the case of the matched symbols.
        //
        // For example, this modifier is specified, string `ABC` would be a complete match for
        // the regex `[a-z]+`.
        //
        // On some platforms may be represented by the `i` flag.
        //
        bool case_insensitive = 2;

        // Enables the `^` (caret) and `$` (dollar) signs to match a start and an end of a line
        // instead of a start and an end of the whole expression.
        //
        // On some platforms may be represented by the `m` flag.
        //
        bool multiline = 3;

        // Enables matching the whole UTF-8 sequences,
        //
        // On some platforms may be represented by the `u` flag.
        //
        bool unicode = 4;

        // Allows the matched strings to contain a full match to the pattern and some other
        // characters as well.
        //
        // By default, a string only matches a pattern if it is a full match, i.e. there are no
        // unaccounted for leading and/or trailing characters.
        //
        // This modifier is usually not represented programming languages, as the control over
        // weather to match an entire string or only its part is provided to the user by other
        // language means. For example, in Java, this would be the difference between methods
        // `matches()` and `find()` of the `java.util.regex.Matcher` class.
        //
        bool partial_match = 5;
    }
}

// Specifies the message to show if a validated field happens to be invalid.
//
// It is applicable only to fields marked with `(validate)`.
//
message IfInvalidOption {

    // Do not specify error message for `(validate)`, it is no longer used by
    // the validation library.
    option deprecated = true;

    // The default error message.
    option (default_message) = "The field `${parent.type}.${field.path}` of the type"
        " `${field.type}` is invalid. The field value: `${field.value}`.";

    // A user-defined validation error format message.
    //
    // Use `error_msg` instead.
    //
    string msg_format = 1 [deprecated = true];

    // A user-defined error message.
    //
    // The specified message may include the following placeholders:
    //
    // 1. `${field.path}` – the field path.
    // 2. `${field.value}` - the field value.
    // 3. `${field.type}` – the fully qualified name of the field type.
    // 4. `${parent.type}` – the fully qualified name of the field declaring type.
    //
    // The placeholders will be replaced at runtime when the error is constructed.
    //
    // Example: using the `(if_invalid)` option.
    //
    //     message Transaction {
    //         TransactionDetails details = 1 [(validate) = true,
    //                                         (if_invalid).error_msg = "The `${field.path}` field is invalid."];
    //    }
    //
    string error_msg = 2;
}

// Specifies that another field must be present if the option's target field is present.
//
// Unlike the `required_field` that handles combination of required fields, this option is useful
// when it is needed to say that an optional field makes sense only when another optional field
// is present.
//
// This option can be applied to the same field types as `(required)`, including both the
// target field and its companion. Supported field types are:
//
// - Messages and enums.
// - Repeated fields and maps.
// - `string` and `bytes`.
//
// Example: requiring mutual presence of optional fields.
//
//    message ScheduledItem {
//        ...
//        spine.time.LocalDate date = 4;
//        spine.time.LocalTime time = 5 [(goes).with = "date"];
//    }
//
message GoesOption {

    // The default error message.
    option (default_message) = "The field `${goes.companion}` must also be set when `${field.path}`"
        " is set in `${parent.type}`.";

    // The name of the companion field whose presence is required for this field to be valid.
    string with = 1;

    // A user-defined validation error format message.
    string msg_format = 2 [deprecated = true];

    // A user-defined error message.
    //
    // The specified message may include the following placeholders:
    //
    // 1. `${field.path}` – the field path.
    // 2. `${field.value}` – the field value.
    // 3. `${field.type}` – the fully qualified name of the field type.
    // 4. `${parent.type}` – the fully qualified name of the validated message.
    // 5. `${goes.companion}` – the name of the companion specified in `with`.
    //
    // The placeholders will be replaced at runtime when the error is constructed.
    //
    string error_msg = 3;
}

// Defines options of a message representing a state of an entity.
message EntityOption {

    // A type of an entity for state of which the message is defined.
    enum Kind {
        option allow_alias = true;
        
        // Reserved for errors.
        KIND_UNKNOWN = 0;

        // The message is an aggregate state.
        AGGREGATE = 1;

        // The message is a state of a projection (same as "view").
        PROJECTION = 2;

        // The message is a state of a view (same as "projection").
        VIEW = 2;

        // The message is a state of a process manager.
        PROCESS_MANAGER = 3;

        // The message is a state of an entity, which is not of the type
        // defined by other members of this enumeration.
        ENTITY = 4;
    }

    // The type of the entity.
    Kind kind = 1;

    // The level of visibility of the entity to queries.
    enum Visibility {

        // Default visibility is different for different types of entities:
        //  - for projections, "FULL" is default;
        //  - for aggregates, process managers, and other entities, "NONE" is default.
        //
        DEFAULT = 0;

        // The entity is not visible to queries.
        NONE = 1;

        // Client-side applications can subscribe to updates of entities of this type.
        SUBSCRIBE = 2;

        // Client-side applications can query this type of entities.
        QUERY = 3;

        // Client-side applications can subscribe and query this type of entity.
        FULL = 4;
    }

    // The visibility of the entity.
    //
    // If not defined, the value of this option is `DEFAULT`.
    //
    Visibility visibility = 2;
}

// Defines a common type for message types declared in the same proto file.
//
// The nature of the type depends on the target programming language.
// For example, the `java_type` property defines a name of the Java interface common
// to all message classes generated for the proto file having this option.
//
// The option triggers creation of the common type if the `generate` property is set to true.
// Otherwise, it is expected that the user provides the reference to an existing type.
//
message EveryIsOption {

    // Enables the generation of the common type.
    //
    // The default value is `false`.
    //
    bool generate = 1;

    // The reference to a Java top-level interface.
    //
    // The interface cannot be nested into a class or another interface.
    // If a nested interface is provided, the code generation should fail the build process.
    //
    // The value may be a fully-qualified or a simple name.
    //
    // When a simple name is set, it is assumed that the interface belongs to
    // the package of the generated message classes.
    //
    // If the value of the `generate` field is set to `false` the referenced interface must exist.
    // Otherwise, a compilation error will occur.
    //
    // If the value of the `generate` field is set to `true`, the framework will
    // generate the interface using the given name and the package as described above.
    //
    // The generated interface will extend `com.google.protobuf.Message` and
    // will have no declared methods.
    //
    string java_type = 2;
}

// Defines additional type for a message type in which this option is declared.
//
// The nature of the type depends on the target programming language.
// For example, the `java_type` property defines a name of the Java interface which
// the generated message class will implement.
//
message IsOption {

    // The reference to a Java top-level interface.
    //
    // The interface cannot be nested into a class or another interface.
    // If a nested interface is provided, the code generation should fail the build process.
    //
    // The value may be a fully-qualified or a simple name.
    //
    // When a simple name is set, it is assumed that the interface belongs to
    // the package of the generated message classes.
    //
    // The referenced interface must exist. Otherwise, a compilation error will occur.
    //
    string java_type = 1;
}

// Defines the way to compare two messages of the same type to one another.
//
// Comparisons can be used to sort values.
//
// See the `(compare_by)` option.
//
message CompareByOption {

    // Field paths used for comparisons.
    //
    // The allowed field types are:
    //  - any number type;
    //  - `bool` (`false` is less than `true`);
    //  - `string` (in the order of respective Unicode values);
    //  - enumerations (following the order of numbers associated with each constant);
    //  - local messages (generated within the current build) marked with `(compare_by)`;
    //  - external messages (from dependencies), which either marked with `(compare_by)`
    //    OR have a comparator provided in `io.spine.compare.ComparatorRegistry`.
    //
    // Other types are not permitted. Repeated or map fields are not permitted either.
    // Such declarations will lead to build-time errors.
    //
    // To refer to nested fields, separate the field names with a dot (`.`).
    // No fields in the path can be repeated or maps.
    //
    // When multiple field paths are specified, comparison is executed in the order of reference.
    // For example, specifying `["seconds", "nanos"]` makes the comparison mechanism prioritize
    // the `seconds` field and refer to `nanos` only when `seconds` are equal.
    //
    // NOTE: When comparing fields with a message type, a non-set message is always less than
    // a set message. But if a message is set to a default value, the comparison falls back to
    // the field-wise comparison, i.e. number values are treated as zeros, `bool` — as `false`,
    // and so on.
    //
    repeated string field = 1;

    // If true, the default order is reversed. For example, numbers are ordered from the greater to
    // the lower, enums — from the last number value to the 0th value, etc.
    bool descending = 2;
}

// Defines the error message used if a `set_once` field is set again.
//
// Applies only to the fields marked as `set_once`.
//
message IfSetAgainOption {

    // The default error message.
    option (default_message) = "The field `${parent.type}.${field.path}` of the type"
        " `${field.type}` already has the value `${field.value}` and cannot be reassigned"
        " to `${field.proposed_value}`.";

    // A user-defined error message.
    //
    // The specified message may include the following placeholders:
    //
    // 1. `${field.path}` – the field path.
    // 2. `${field.type}` – the fully qualified name of the field type.
    // 3. `${field.value}` – the current field value.
    // 4. `${field.proposed_value}` – the value, which was attempted to be set.
    // 5. `${parent.type}` – the fully qualified name of the validated message.
    //
    // The placeholders will be replaced at runtime when the error is constructed.
    //
    // Example: using the `(set_once)` option.
    //
    //     message User {
    //         UserId id = 1 [(set_once) = true,
    //                        (if_set_again).error_msg = "A student ID is used as a permanent identifier within academic system, and cannot be re-assigned."];
    //     }
    //
    string error_msg = 1;
}

// Defines the error message used if a `distinct` field has duplicates.
//
// Applies only to the `repeated` and `map` fields marked with the `(distinct)` option.
//
message IfHasDuplicatesOption {

    // The default error message.
    option (default_message) = "The field `${parent.type}.${field.path}` of the type"
        " `${field.type}` must not contain duplicates."
        " The duplicates found: `${field.duplicates}`.";

    // A user-defined error message.
    //
    // The specified message may include the following placeholders:
    //
    // 1. `${field.path}` – the field path.
    // 2. `${field.type}` – the fully qualified name of the field type.
    // 3. `${field.value}` – the field value (the whole collection).
    // 4. `${field.duplicates}` – the duplicates found (elements that occur more than once).
    // 5. `${parent.type}` – the fully qualified name of the validated message.
    //
    // The placeholders will be replaced at runtime when the error is constructed.
    //
    // Example: using the `(distinct)` option.
    //
    //    message Blizzard {
    //        repeated Snowflake = 1 [(distinct) = true,
    //                                (if_has_duplicates).error_msg = "Every snowflake must be unique! The duplicates found: `${field.duplicates}`."];
    //    }
    //
    string error_msg = 1;
}

// Indicate that the numeric field must belong to the specified bounded range.
//
// For unbounded ranges, please use `(min)` and `(max) options.
//
// The option supports all singular and repeated numeric fields.
//
message RangeOption {

    // The default error message.
    option (default_message) = "The field `${parent.type}.${field.path}` must be within"
        " the following range: `${range.value}`. The passed value: `${field.value}`.";

    // The string representation of the range.
    //
    // A range consists of two bounds: a lower bound and an upper bound. These bounds are
    // separated by either the `..` or ` .. ` delimiter. Each bound can be either open
    // or closed. The format of the bounds and the valid values depend on the type of field.
    //
    // ## Bound Types
    //
    // - Closed bounds include the endpoint and are indicated using square brackets (`[`, `]`).
    //   Example: `[0..10]` represents values from 0 to 10, inclusive.
    //
    // - Open bounds exclude the endpoint and are indicated using parentheses (`(`, `)`).
    //   Example: `(0..10)` represents values strictly between 0 and 10.
    //
    // The lower bound must be less than or equal to the upper bound.
    //
    // ## Integer Fields
    //
    // A range for an integer field must use integer numbers. Specifying a decimal number
    // is not allowed, even if it has no fractional part (e.g., `5.0` is invalid).
    //
    // Example: defining ranges for integer fields.
    //
    // message Measurements {
    //      int32 length = 1 [(range).value = "[0..100)"];
    //      uint32 mass = 2 [(range).value = "(0..100]"];
    //  }
    //
    // ## Floating-Point Fields
    //
    // A range for a floating-point field must use a decimal separator (`.`), even if the value
    // has no fractional part. An exponent part represented by `E` or `e`, followed by an optional
    // sign and digits is allowed (e.g., `1.2E3`, `0.5e-2`).
    //
    // Example: defining ranges for floating-point fields.
    //
    // message Measurements {
    //     float degree = 1 [(range).value = "[0.0 .. 360.0)"];
    //     double angle = 2 [(range).value = "(0.0 .. 180.0)"];
    //     float pressure = 3 [(range).value = "[950.0E-2 .. 1050.0E-2]"];
    // }
    //
    // ## Field Type Limitations
    //
    // A range must not exceed the limits of the field type.
    //
    // Example: invalid ranges that exceed the field type limits.
    //
    // message OverflowMeasurements {
    //     float price = 1 [(range).value = "[0, 5.5E38]"]; // Exceeds the `float` maximum.
    //     uint32 size = 2 [(range).value = "[-5; 10]"]; // Falls below the `uint32` minimum.
    // }
    //
    // ## Field references
    //
    // Instead of numeric literals, you can reference another numeric field.
    // At runtime, the field’s value will be used as the bound. Nested fields are supported.
    //
    // Example: defining ranges using field references.
    //
    // message Measurements {
    //
    //     int32 max_length = 1;
    //     int32 length = 2 [(range).value = "[1 .. max_length"];
    //
    //     Limits limits = 3;
    //     int32 temperature = 4 [(range).value = "[limits.low_temp .. limits.high_temp]"];
    // }
    //
    // message Limits {
    //     int32 low_temp = 1;
    //     int32 high_temp = 2;
    // }
    //
    // Note: Field type compatibility is not required in this case; the value is
    // automatically converted. However, only numeric fields can be referenced.
    // Repeated and map fields are not supported.
    //
    string value = 1;

    // A user-defined error message.
    //
    // The specified message may include the following placeholders:
    //
    // 1. `${field.path}` – the field path.
    // 2. `${field.value}` - the field value.
    // 3. `${field.type}` – the fully qualified name of the field type.
    // 4. `${parent.type}` – the fully qualified name of the validated message.
    // 5. `${range.value}` – the specified range. For referenced fields, the actual
    //    field value is also printed in round brackets along with the reference itself.
    //
    // The placeholders will be replaced at runtime when the error is constructed.
    //
    string error_msg = 2;
}

// Controls whether a `oneof` group must always have one of its fields set.
//
// Note that unlike the `(required)` constraint, this option supports any field types
// within the group cases.
//
message ChoiceOption {

    // The default error message.
    option (default_message) = "The `oneof` group `${parent.type}.${group.path}` must"
        " have one of its fields set.";

    // Enables or disables the requirement for the `oneof` group to have a value.
    bool required = 1;

    // A user-defined error message.
    //
    // The specified message may include the following placeholders:
    //
    // 1. `${group.path}` – the group path.
    // 2. `${parent.type}` – the fully qualified name of the validated message.
    //
    // The placeholders will be replaced at runtime when the error is constructed.
    //
    string error_msg = 2;
}

// Declares the field groups, at least one of which must have all of its fields set.
//
// Unlike the `(required)` field constraint, which requires the presence of
// a specific field, this option allows to specify alternative field groups.
//
message RequireOption {

    // The default error message.
    option (default_message) = "The message `${message.type}` must have at least one of"
        " the following field groups set: `${require.fields}`.";

    // A set of field groups, at least one of which must have all of its fields set.
    //
    // A field group can include one or more fields joined by the ampersand (`&`) symbol.
    // `oneof` group names are also valid and can be used along with field names.
    // Groups are separated using the pipe (`|`) symbol.
    //
    // The field type determines when the field is considered set:
    //
    // 1. For message or enum fields, it must have a non-default instance.
    // 2. For `string` and `bytes` fields, it must be non-empty.
    // 3. For repeated fields and maps, it must contain at least one element.
    //
    // Fields of other types are not supported by this option.
    //
    // For `oneof`s, the restrictions above do not apply. Any `oneof` group can be used
    // without considering the field types, and its value will be checked directly without
    // relying on the default values of the fields within the `oneof`.
    //
    // Example: defining two field groups.
    //
    //     message PersonName {
    //         option (require).fields = "given_name | honorific_prefix & family_name";
    //
    //         string honorific_prefix = 1;
    //         string given_name = 2;
    //         string middle_name = 3;
    //         string family_name = 4;
    //         string honorific_suffix = 5;
    //     }
    //
    // In this example, at least `given_name` or a group of `honorific_prefix`
    // and `family_name` fields must be set.
    //
    string fields = 1;

    // A user-defined error message.
    //
    // The specified message may include the following placeholders:
    //
    // 1. `${message.type}` – the fully qualified name of the validated message.
    // 2. `${require.fields}` – the specified field groups.
    //
    // The placeholders will be replaced at runtime when the error is constructed.
    //
    string error_msg = 2;
}
