/*
 * Copyright 2018, TeamDev. All rights reserved.
 *
 * Redistribution and use in source and/or binary forms, with or without
 * modification, must retain the above copyright notice and the following
 * disclaimer.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package io.spine.code.java;

import com.google.common.collect.ImmutableSet;
import io.spine.code.proto.FieldDeclaration;

import java.io.Serializable;
import java.util.Collection;

import static com.google.common.collect.ImmutableSet.toImmutableSet;
import static com.google.protobuf.Descriptors.FieldDescriptor.JavaType.STRING;
import static io.spine.code.java.AccessorTemplate.prefixed;
import static io.spine.code.java.AccessorTemplate.prefixedAndPostfixed;
import static io.spine.code.java.AccessorTemplates.adder;
import static io.spine.code.java.AccessorTemplates.allAdder;
import static io.spine.code.java.AccessorTemplates.allPutter;
import static io.spine.code.java.AccessorTemplates.clearer;
import static io.spine.code.java.AccessorTemplates.getter;
import static io.spine.code.java.AccessorTemplates.listGetter;
import static io.spine.code.java.AccessorTemplates.mapGetter;
import static io.spine.code.java.AccessorTemplates.putter;
import static io.spine.code.java.AccessorTemplates.remover;
import static io.spine.code.java.AccessorTemplates.setter;

/**
 * Property accessor methods generated by the Protobuf compiler.
 *
 * <p>Each Protobuf field results in a number of accessor methods. The count and naming of
 * the methods depends on the field type.
 */
public final class GeneratedAccessors implements Serializable {

    private static final long serialVersionUID = 0L;

    private static final AccessorTemplate COUNT_GETTER = prefixedAndPostfixed("get", "Count");
    private static final String BYTES = "Bytes";

    private final FieldName propertyName;
    private final Type type;

    private GeneratedAccessors(FieldName propertyName, Type type) {
        this.propertyName = propertyName;
        this.type = type;
    }

    /**
     * Creates an instance of {@code GeneratedAccessors} for the given field.
     *
     * @param field
     *         the field associated with the accessors
     * @return new instance
     */
    public static GeneratedAccessors forField(FieldDeclaration field) {
        FieldName javaFieldName = FieldName.from(field.name());
        Type type = Type.of(field);
        return new GeneratedAccessors(javaFieldName, type);
    }

    /**
     * Obtains all the names of the accessor methods.
     *
     * <p>The accessor methods may have different parameters. Some of the obtained names may
     * reference several method overloads.
     */
    public ImmutableSet<String> names() {
        ImmutableSet<String> names = names(type.templates);
        return names;
    }

    private ImmutableSet<String> names(Collection<AccessorTemplate> templates) {
        return templates.stream()
                        .map(template -> template.format(propertyName))
                        .collect(toImmutableSet());
    }

    /**
     * Type of a ProtobufField.
     *
     * <p>Depending in the type, a field has different accessor methods.
     */
    private enum Type {

        /**
         *A singular field of any type but {@code string}.
         *
         * @see #SINGULAR_STRING
         */
        SINGULAR(ImmutableSet.of(prefixed("has"),
                                 getter(),
                                 setter(),
                                 clearer())),

        /**
         * A singular field of {@code string} field.
         *
         * <p>All the accessors of a generic {@link #SINGULAR} field are guaranteed to be included.
         */
        SINGULAR_STRING(ImmutableSet.of(prefixed("has"),
                                        getter(),
                                        prefixedAndPostfixed("get", BYTES),
                                        setter(),
                                        prefixedAndPostfixed("set", BYTES),
                                        clearer())),

        /**
         * A repeated field of any type.
         */
        REPEATED(ImmutableSet.of(getter(),
                                 listGetter(),
                                 COUNT_GETTER,
                                 setter(),
                                 adder(),
                                 allAdder(),
                                 clearer())),

        /**
         * A map field of any type.
         */
        MAP(ImmutableSet.of(getter(),
                            COUNT_GETTER,
                            mapGetter(),
                            prefixedAndPostfixed("get", "OrDefault"),
                            prefixedAndPostfixed("get", "OrThrow"),
                            prefixed("contains"),
                            clearer(),
                            putter(),
                            remover(),
                            allPutter()));

        private final ImmutableSet<AccessorTemplate> templates;

        Type(ImmutableSet<AccessorTemplate> templates) {
            this.templates = templates;
        }

        private static Type of(FieldDeclaration declaration) {
            if (declaration.isMap()) {
                return MAP;
            } else if (declaration.isRepeated()) {
                return REPEATED;
            } else if (declaration.javaType() == STRING) {
                return SINGULAR_STRING;
            } else {
                return SINGULAR;
            }
        }
    }
}
